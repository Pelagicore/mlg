from random import randint
import src.Sentences as Sentences
import binascii, os, shutil, random, hashlib, itertools

class DirectoryTreeGenerator:
	""" Generate a directory tree with random directory names. The tree is
	not actually persisted to disk by this module, and is often modified by
	the generator modules """
	taken_dirs = set([])

	def generate(self, max_depth, num_dirs):
		""" Generate a representation of a directory tree, which is
		suitable for writing to disk using createDirectoryTree, or for
		placing files in using placeFiles.
		Parameters
		----------
		max_depth : int
			Max depth of a single directory path (e.g. /a/b/c = 3)
		num_dirs : int
			Number of directories to create, this includes any
			subdirectories
		"""
		root = []
		while (num_dirs > 0):
			# 10% of the directories are created in the root
			if root == [] or randint(1,10) == 1:
				root.append(self._new_dir([]))
				num_dirs = num_dirs - 1
			else:
				p = root[randint(0, len(root)-1)]
				if len(p) < max_depth:
					root.append(self._new_dir(p))
					num_dirs = num_dirs - 1
		return root

	def _new_dir(self, root):
		candidate = self._generate_filename()
		while (candidate not in self.taken_dirs):
			candidate = self._generate_filename()
			return root + [candidate]

	def _generate_filename(self):
		return hashlib.md5(str(random.random())).hexdigest()\
		          [:-randint(0,25)]

class FilePlacer:
	""" Place files in the directory tree generated by the
	DirectoryTreeGenerator. May optionally modify sections of the tree """
	remaining_tree = None
	actions = []

	def __init__(self, tree):
		self.remaining_tree = tree

	def printActions(self):
		""" Print the list of actions to carry out """
		for (src, dest) in self.actions:
			print "%s --> %s" % (src, "/".join(dest))

	def placeFileGenerator(self, generator):
		""" Place a file using the generator object to retrieve the
		file name
		Parameters
		----------
		generator: an object providing paths by getFile()
			Generator providing the file to be moved
		"""
		if len(self.remaining_tree) > 0:
			d = self.remaining_tree.pop(
				randint(0,len(self.remaining_tree)-1))
			f = generator.getFile()
			self._placeFile(f, d)

	def generateAlbum(self, args, gen):
		""" Generates an album according to the specified naming
		strategy, will randomize the number of files contained in the
		album according to set limits
		Parameters
		----------
		args: dict
			A dict of the parameters supplied to argparse
		gen: A FileGenerator object
			Used to generate the files to be placed
		"""
		num_generated = 0
		artists = itertools.cycle((Sentences.getSentence() for x
		           in range(0,args.num_artists)))
		albums = itertools.cycle((Sentences.getSentence() for x
		           in range(0,args.num_files)))
		albums = itertools.cycle(albums)
		props = {k:v for k,v in vars(args).iteritems() if v != None}

		while (num_generated < args.num_files):
			artist = artists.next()
			for i in range(0,args.max_albums_per_artist):
				print args.album_naming_strategy
				album = albums.next()
				f_album = self._generateAlbumName(
			                          args.album_naming_strategy,
			                          artist, album)
				if not f_album:
					f_album = albums.next()
				if (num_generated >= args.num_files):
					break
				remaining = args.num_files - num_generated
				props["artist"] = artist
				props["album"] = album
				gen.setPersistantProperties(props)
				numberOfTracks = randint(
				    min(remaining, args.min_files_per_album),
				    min(remaining, args.max_files_per_album))
				self._placeAlbum(numberOfTracks, gen, f_album)
				num_generated = num_generated +\
						numberOfTracks
		self._performActions(args.destination_dir)

	def generateSingles(self, args, gen):
		""" Generate and place a single files in directories, will
		generate args.num_files files.
		Parameters
		----------
		args: dict
			A dictionary generated from the parameters supplied to
			argparse
		gen: A FileGenerator
			Used to generate all single files
		"""
		num_generated = 0
		artists = itertools.cycle((Sentences.getSentence() for x
		           in range(0,args.num_artists)))
		albums = itertools.cycle((Sentences.getSentence() for x
		           in range(0,args.num_files)))
		albums = itertools.cycle(albums)
		props = {k:v for k,v in vars(args).iteritems() if v != None}

		while (num_generated < args.num_files):
			artist = artists.next()
			album = albums.next()
			if album: props["album"] = album
			gen.setPersistantProperties(props)
			self.placeFileGenerator(gen)
			num_generated = num_generated + 1
		self._performActions(args.destination_dir)


	def _placeAlbum(self, albumSize, fileGenerator, override_dirname = None):
		""" Place several files in an album-like structure. This is
		used to ensure files are placed together, emulating an album
		structure of a music collection, or photo collection for
		instance.
		Parameters
		----------
		albumSize: Number
			Number indicating the number of files to be placed in
			this album
		fileGenerator: An object supplying filenames by .getFile()
			The generator object to get files from, should be
			capable of supplying at least albumSize number of files
		override_dirname: string
			Set to the desired 'final' dirname, e.g c in /a/b/c.
			The dirname supplied by the generated tree is
			overridden
		"""
		if len(self.remaining_tree) > 0:
			d = self.remaining_tree.pop(
				randint(0,len(self.remaining_tree)-1))
			if (override_dirname):
				d[-1] = override_dirname
			p = "/".join(d)
			for i in range (0, albumSize):
				f = fileGenerator.getFile()
				self._placeFile(f, d)
		else:
			print "Tree is empty!"

	def _generateAlbumName(self, scheme, artist, album):
		""" Generate an album name, potentially consuming elements from
		the artists and albums
		Parameters
		----------
		scheme: string
			Details the strateby to use when generating album
			names, "music" and "date" are supported
		artists: Something iterable with .next()
			Pool of artists to pick from
		albums: Something iterable with .next()
			Pool of albums to pick from
		"""
		if scheme == "music":
			return "%s - %s" % (artist, album)
		if scheme == "date":
			return "%s-%02d" %\
			  (random.randint(1970,2013), random.randint(1,12))
		else:
			return hashlib.md5(str(random.random())).hexdigest()\
			                            [:-randint(0,25)]

	def _placeFile(self, src, dest):
		""" Create an action to place a file, the action is committed
		using the _performActions function.
		Parameters
		----------
		src: string
			string containing the full filename of the file to move
		dest: string
			string of the destination directory
		"""
		self.actions.append((src, dest))

	def _performActions(self, base = "/tmp/"):
		""" Perform the moving specified using _placeFile """
		for (src, dest) in self.actions:
			dest = "/".join(dest)
			print "base is %s" % base
			full = "/".join([base, dest])
			print "Full is %s" % full
			try:
				os.makedirs(full)
			except OSError:
				pass
			print "Moving %s to %s" % (src, full)
			try:
				shutil.move(src, full)
			except:
				print "Failed to move %s to %s" % (src, full)
